// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mock

//go:generate minimock -i gitlab.ozon.dev/ipogiba/homework/loms/internal/service/order.IOrderRepo -o order_repo_mock.go -n OrderRepoMock -p mock

import (
	"context"
	"gitlab.ozon.dev/ipogiba/homework/loms/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrderRepoMock implements order.IOrderRepo
type OrderRepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrder          func(ctx context.Context, userID int64, items []*model.Item) (op1 *model.Order)
	inspectFuncCreateOrder   func(ctx context.Context, userID int64, items []*model.Item)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mOrderRepoMockCreateOrder

	funcGetOrderByID          func(ctx context.Context, id int64) (op1 *model.Order, err error)
	inspectFuncGetOrderByID   func(ctx context.Context, id int64)
	afterGetOrderByIDCounter  uint64
	beforeGetOrderByIDCounter uint64
	GetOrderByIDMock          mOrderRepoMockGetOrderByID

	funcSetStatus          func(ctx context.Context, id int64, status model.Status) (err error)
	inspectFuncSetStatus   func(ctx context.Context, id int64, status model.Status)
	afterSetStatusCounter  uint64
	beforeSetStatusCounter uint64
	SetStatusMock          mOrderRepoMockSetStatus
}

// NewOrderRepoMock returns a mock for order.IOrderRepo
func NewOrderRepoMock(t minimock.Tester) *OrderRepoMock {
	m := &OrderRepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mOrderRepoMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*OrderRepoMockCreateOrderParams{}

	m.GetOrderByIDMock = mOrderRepoMockGetOrderByID{mock: m}
	m.GetOrderByIDMock.callArgs = []*OrderRepoMockGetOrderByIDParams{}

	m.SetStatusMock = mOrderRepoMockSetStatus{mock: m}
	m.SetStatusMock.callArgs = []*OrderRepoMockSetStatusParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrderRepoMockCreateOrder struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockCreateOrderExpectation
	expectations       []*OrderRepoMockCreateOrderExpectation

	callArgs []*OrderRepoMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockCreateOrderExpectation specifies expectation struct of the IOrderRepo.CreateOrder
type OrderRepoMockCreateOrderExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockCreateOrderParams
	paramPtrs *OrderRepoMockCreateOrderParamPtrs
	results   *OrderRepoMockCreateOrderResults
	Counter   uint64
}

// OrderRepoMockCreateOrderParams contains parameters of the IOrderRepo.CreateOrder
type OrderRepoMockCreateOrderParams struct {
	ctx    context.Context
	userID int64
	items  []*model.Item
}

// OrderRepoMockCreateOrderParamPtrs contains pointers to parameters of the IOrderRepo.CreateOrder
type OrderRepoMockCreateOrderParamPtrs struct {
	ctx    *context.Context
	userID *int64
	items  *[]*model.Item
}

// OrderRepoMockCreateOrderResults contains results of the IOrderRepo.CreateOrder
type OrderRepoMockCreateOrderResults struct {
	op1 *model.Order
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mOrderRepoMockCreateOrder) Optional() *mOrderRepoMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for IOrderRepo.CreateOrder
func (mmCreateOrder *mOrderRepoMockCreateOrder) Expect(ctx context.Context, userID int64, items []*model.Item) *mOrderRepoMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepoMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &OrderRepoMockCreateOrderParams{ctx, userID, items}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepo.CreateOrder
func (mmCreateOrder *mOrderRepoMockCreateOrder) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepoMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &OrderRepoMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateOrder
}

// ExpectUserIDParam2 sets up expected param userID for IOrderRepo.CreateOrder
func (mmCreateOrder *mOrderRepoMockCreateOrder) ExpectUserIDParam2(userID int64) *mOrderRepoMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepoMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &OrderRepoMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.userID = &userID

	return mmCreateOrder
}

// ExpectItemsParam3 sets up expected param items for IOrderRepo.CreateOrder
func (mmCreateOrder *mOrderRepoMockCreateOrder) ExpectItemsParam3(items []*model.Item) *mOrderRepoMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepoMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &OrderRepoMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.items = &items

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepo.CreateOrder
func (mmCreateOrder *mOrderRepoMockCreateOrder) Inspect(f func(ctx context.Context, userID int64, items []*model.Item)) *mOrderRepoMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by IOrderRepo.CreateOrder
func (mmCreateOrder *mOrderRepoMockCreateOrder) Return(op1 *model.Order) *OrderRepoMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderRepoMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &OrderRepoMockCreateOrderResults{op1}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the IOrderRepo.CreateOrder method
func (mmCreateOrder *mOrderRepoMockCreateOrder) Set(f func(ctx context.Context, userID int64, items []*model.Item) (op1 *model.Order)) *OrderRepoMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the IOrderRepo.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the IOrderRepo.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the IOrderRepo.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mOrderRepoMockCreateOrder) When(ctx context.Context, userID int64, items []*model.Item) *OrderRepoMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderRepoMock.CreateOrder mock is already set by Set")
	}

	expectation := &OrderRepoMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &OrderRepoMockCreateOrderParams{ctx, userID, items},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepo.CreateOrder return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockCreateOrderExpectation) Then(op1 *model.Order) *OrderRepoMock {
	e.results = &OrderRepoMockCreateOrderResults{op1}
	return e.mock
}

// Times sets number of times IOrderRepo.CreateOrder should be invoked
func (mmCreateOrder *mOrderRepoMockCreateOrder) Times(n uint64) *mOrderRepoMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of OrderRepoMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	return mmCreateOrder
}

func (mmCreateOrder *mOrderRepoMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements order.IOrderRepo
func (mmCreateOrder *OrderRepoMock) CreateOrder(ctx context.Context, userID int64, items []*model.Item) (op1 *model.Order) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, userID, items)
	}

	mm_params := OrderRepoMockCreateOrderParams{ctx, userID, items}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockCreateOrderParams{ctx, userID, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrder.t.Errorf("OrderRepoMock.CreateOrder got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCreateOrder.t.Errorf("OrderRepoMock.CreateOrder got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmCreateOrder.t.Errorf("OrderRepoMock.CreateOrder got unexpected parameter items, want: %#v, got: %#v%s\n", *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("OrderRepoMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the OrderRepoMock.CreateOrder")
		}
		return (*mm_results).op1
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, userID, items)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to OrderRepoMock.CreateOrder. %v %v %v", ctx, userID, items)
	return
}

// CreateOrderAfterCounter returns a count of finished OrderRepoMock.CreateOrder invocations
func (mmCreateOrder *OrderRepoMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of OrderRepoMock.CreateOrder invocations
func (mmCreateOrder *OrderRepoMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mOrderRepoMockCreateOrder) Calls() []*OrderRepoMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*OrderRepoMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.CreateOrder with params: %#v", *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.CreateOrder")
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.CreateOrder but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), afterCreateOrderCounter)
	}
}

type mOrderRepoMockGetOrderByID struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockGetOrderByIDExpectation
	expectations       []*OrderRepoMockGetOrderByIDExpectation

	callArgs []*OrderRepoMockGetOrderByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockGetOrderByIDExpectation specifies expectation struct of the IOrderRepo.GetOrderByID
type OrderRepoMockGetOrderByIDExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockGetOrderByIDParams
	paramPtrs *OrderRepoMockGetOrderByIDParamPtrs
	results   *OrderRepoMockGetOrderByIDResults
	Counter   uint64
}

// OrderRepoMockGetOrderByIDParams contains parameters of the IOrderRepo.GetOrderByID
type OrderRepoMockGetOrderByIDParams struct {
	ctx context.Context
	id  int64
}

// OrderRepoMockGetOrderByIDParamPtrs contains pointers to parameters of the IOrderRepo.GetOrderByID
type OrderRepoMockGetOrderByIDParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// OrderRepoMockGetOrderByIDResults contains results of the IOrderRepo.GetOrderByID
type OrderRepoMockGetOrderByIDResults struct {
	op1 *model.Order
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) Optional() *mOrderRepoMockGetOrderByID {
	mmGetOrderByID.optional = true
	return mmGetOrderByID
}

// Expect sets up expected params for IOrderRepo.GetOrderByID
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) Expect(ctx context.Context, id int64) *mOrderRepoMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepoMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoMock.GetOrderByID mock is already set by ExpectParams functions")
	}

	mmGetOrderByID.defaultExpectation.params = &OrderRepoMockGetOrderByIDParams{ctx, id}
	for _, e := range mmGetOrderByID.expectations {
		if minimock.Equal(e.params, mmGetOrderByID.defaultExpectation.params) {
			mmGetOrderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderByID.defaultExpectation.params)
		}
	}

	return mmGetOrderByID
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepo.GetOrderByID
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepoMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.params != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoMock.GetOrderByID mock is already set by Expect")
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderByID.defaultExpectation.paramPtrs = &OrderRepoMockGetOrderByIDParamPtrs{}
	}
	mmGetOrderByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetOrderByID
}

// ExpectIdParam2 sets up expected param id for IOrderRepo.GetOrderByID
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) ExpectIdParam2(id int64) *mOrderRepoMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepoMockGetOrderByIDExpectation{}
	}

	if mmGetOrderByID.defaultExpectation.params != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoMock.GetOrderByID mock is already set by Expect")
	}

	if mmGetOrderByID.defaultExpectation.paramPtrs == nil {
		mmGetOrderByID.defaultExpectation.paramPtrs = &OrderRepoMockGetOrderByIDParamPtrs{}
	}
	mmGetOrderByID.defaultExpectation.paramPtrs.id = &id

	return mmGetOrderByID
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepo.GetOrderByID
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) Inspect(f func(ctx context.Context, id int64)) *mOrderRepoMockGetOrderByID {
	if mmGetOrderByID.mock.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.GetOrderByID")
	}

	mmGetOrderByID.mock.inspectFuncGetOrderByID = f

	return mmGetOrderByID
}

// Return sets up results that will be returned by IOrderRepo.GetOrderByID
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) Return(op1 *model.Order, err error) *OrderRepoMock {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &OrderRepoMockGetOrderByIDExpectation{mock: mmGetOrderByID.mock}
	}
	mmGetOrderByID.defaultExpectation.results = &OrderRepoMockGetOrderByIDResults{op1, err}
	return mmGetOrderByID.mock
}

// Set uses given function f to mock the IOrderRepo.GetOrderByID method
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) Set(f func(ctx context.Context, id int64) (op1 *model.Order, err error)) *OrderRepoMock {
	if mmGetOrderByID.defaultExpectation != nil {
		mmGetOrderByID.mock.t.Fatalf("Default expectation is already set for the IOrderRepo.GetOrderByID method")
	}

	if len(mmGetOrderByID.expectations) > 0 {
		mmGetOrderByID.mock.t.Fatalf("Some expectations are already set for the IOrderRepo.GetOrderByID method")
	}

	mmGetOrderByID.mock.funcGetOrderByID = f
	return mmGetOrderByID.mock
}

// When sets expectation for the IOrderRepo.GetOrderByID which will trigger the result defined by the following
// Then helper
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) When(ctx context.Context, id int64) *OrderRepoMockGetOrderByIDExpectation {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("OrderRepoMock.GetOrderByID mock is already set by Set")
	}

	expectation := &OrderRepoMockGetOrderByIDExpectation{
		mock:   mmGetOrderByID.mock,
		params: &OrderRepoMockGetOrderByIDParams{ctx, id},
	}
	mmGetOrderByID.expectations = append(mmGetOrderByID.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepo.GetOrderByID return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockGetOrderByIDExpectation) Then(op1 *model.Order, err error) *OrderRepoMock {
	e.results = &OrderRepoMockGetOrderByIDResults{op1, err}
	return e.mock
}

// Times sets number of times IOrderRepo.GetOrderByID should be invoked
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) Times(n uint64) *mOrderRepoMockGetOrderByID {
	if n == 0 {
		mmGetOrderByID.mock.t.Fatalf("Times of OrderRepoMock.GetOrderByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrderByID.expectedInvocations, n)
	return mmGetOrderByID
}

func (mmGetOrderByID *mOrderRepoMockGetOrderByID) invocationsDone() bool {
	if len(mmGetOrderByID.expectations) == 0 && mmGetOrderByID.defaultExpectation == nil && mmGetOrderByID.mock.funcGetOrderByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrderByID.mock.afterGetOrderByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrderByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrderByID implements order.IOrderRepo
func (mmGetOrderByID *OrderRepoMock) GetOrderByID(ctx context.Context, id int64) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrderByID.beforeGetOrderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderByID.afterGetOrderByIDCounter, 1)

	if mmGetOrderByID.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.inspectFuncGetOrderByID(ctx, id)
	}

	mm_params := OrderRepoMockGetOrderByIDParams{ctx, id}

	// Record call args
	mmGetOrderByID.GetOrderByIDMock.mutex.Lock()
	mmGetOrderByID.GetOrderByIDMock.callArgs = append(mmGetOrderByID.GetOrderByIDMock.callArgs, &mm_params)
	mmGetOrderByID.GetOrderByIDMock.mutex.Unlock()

	for _, e := range mmGetOrderByID.GetOrderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetOrderByID.GetOrderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderByID.GetOrderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockGetOrderByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOrderByID.t.Errorf("OrderRepoMock.GetOrderByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetOrderByID.t.Errorf("OrderRepoMock.GetOrderByID got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderByID.t.Errorf("OrderRepoMock.GetOrderByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderByID.t.Fatal("No results are set for the OrderRepoMock.GetOrderByID")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetOrderByID.funcGetOrderByID != nil {
		return mmGetOrderByID.funcGetOrderByID(ctx, id)
	}
	mmGetOrderByID.t.Fatalf("Unexpected call to OrderRepoMock.GetOrderByID. %v %v", ctx, id)
	return
}

// GetOrderByIDAfterCounter returns a count of finished OrderRepoMock.GetOrderByID invocations
func (mmGetOrderByID *OrderRepoMock) GetOrderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.afterGetOrderByIDCounter)
}

// GetOrderByIDBeforeCounter returns a count of OrderRepoMock.GetOrderByID invocations
func (mmGetOrderByID *OrderRepoMock) GetOrderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.beforeGetOrderByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.GetOrderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderByID *mOrderRepoMockGetOrderByID) Calls() []*OrderRepoMockGetOrderByIDParams {
	mmGetOrderByID.mutex.RLock()

	argCopy := make([]*OrderRepoMockGetOrderByIDParams, len(mmGetOrderByID.callArgs))
	copy(argCopy, mmGetOrderByID.callArgs)

	mmGetOrderByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderByIDDone returns true if the count of the GetOrderByID invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockGetOrderByIDDone() bool {
	if m.GetOrderByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderByIDMock.invocationsDone()
}

// MinimockGetOrderByIDInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockGetOrderByIDInspect() {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.GetOrderByID with params: %#v", *e.params)
		}
	}

	afterGetOrderByIDCounter := mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && afterGetOrderByIDCounter < 1 {
		if m.GetOrderByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.GetOrderByID")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.GetOrderByID with params: %#v", *m.GetOrderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && afterGetOrderByIDCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.GetOrderByID")
	}

	if !m.GetOrderByIDMock.invocationsDone() && afterGetOrderByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.GetOrderByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderByIDMock.expectedInvocations), afterGetOrderByIDCounter)
	}
}

type mOrderRepoMockSetStatus struct {
	optional           bool
	mock               *OrderRepoMock
	defaultExpectation *OrderRepoMockSetStatusExpectation
	expectations       []*OrderRepoMockSetStatusExpectation

	callArgs []*OrderRepoMockSetStatusParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// OrderRepoMockSetStatusExpectation specifies expectation struct of the IOrderRepo.SetStatus
type OrderRepoMockSetStatusExpectation struct {
	mock      *OrderRepoMock
	params    *OrderRepoMockSetStatusParams
	paramPtrs *OrderRepoMockSetStatusParamPtrs
	results   *OrderRepoMockSetStatusResults
	Counter   uint64
}

// OrderRepoMockSetStatusParams contains parameters of the IOrderRepo.SetStatus
type OrderRepoMockSetStatusParams struct {
	ctx    context.Context
	id     int64
	status model.Status
}

// OrderRepoMockSetStatusParamPtrs contains pointers to parameters of the IOrderRepo.SetStatus
type OrderRepoMockSetStatusParamPtrs struct {
	ctx    *context.Context
	id     *int64
	status *model.Status
}

// OrderRepoMockSetStatusResults contains results of the IOrderRepo.SetStatus
type OrderRepoMockSetStatusResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetStatus *mOrderRepoMockSetStatus) Optional() *mOrderRepoMockSetStatus {
	mmSetStatus.optional = true
	return mmSetStatus
}

// Expect sets up expected params for IOrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) Expect(ctx context.Context, id int64, status model.Status) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.paramPtrs != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by ExpectParams functions")
	}

	mmSetStatus.defaultExpectation.params = &OrderRepoMockSetStatusParams{ctx, id, status}
	for _, e := range mmSetStatus.expectations {
		if minimock.Equal(e.params, mmSetStatus.defaultExpectation.params) {
			mmSetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetStatus.defaultExpectation.params)
		}
	}

	return mmSetStatus
}

// ExpectCtxParam1 sets up expected param ctx for IOrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) ExpectCtxParam1(ctx context.Context) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepoMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSetStatus
}

// ExpectIdParam2 sets up expected param id for IOrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) ExpectIdParam2(id int64) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepoMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.id = &id

	return mmSetStatus
}

// ExpectStatusParam3 sets up expected param status for IOrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) ExpectStatusParam3(status model.Status) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{}
	}

	if mmSetStatus.defaultExpectation.params != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Expect")
	}

	if mmSetStatus.defaultExpectation.paramPtrs == nil {
		mmSetStatus.defaultExpectation.paramPtrs = &OrderRepoMockSetStatusParamPtrs{}
	}
	mmSetStatus.defaultExpectation.paramPtrs.status = &status

	return mmSetStatus
}

// Inspect accepts an inspector function that has same arguments as the IOrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) Inspect(f func(ctx context.Context, id int64, status model.Status)) *mOrderRepoMockSetStatus {
	if mmSetStatus.mock.inspectFuncSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("Inspect function is already set for OrderRepoMock.SetStatus")
	}

	mmSetStatus.mock.inspectFuncSetStatus = f

	return mmSetStatus
}

// Return sets up results that will be returned by IOrderRepo.SetStatus
func (mmSetStatus *mOrderRepoMockSetStatus) Return(err error) *OrderRepoMock {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	if mmSetStatus.defaultExpectation == nil {
		mmSetStatus.defaultExpectation = &OrderRepoMockSetStatusExpectation{mock: mmSetStatus.mock}
	}
	mmSetStatus.defaultExpectation.results = &OrderRepoMockSetStatusResults{err}
	return mmSetStatus.mock
}

// Set uses given function f to mock the IOrderRepo.SetStatus method
func (mmSetStatus *mOrderRepoMockSetStatus) Set(f func(ctx context.Context, id int64, status model.Status) (err error)) *OrderRepoMock {
	if mmSetStatus.defaultExpectation != nil {
		mmSetStatus.mock.t.Fatalf("Default expectation is already set for the IOrderRepo.SetStatus method")
	}

	if len(mmSetStatus.expectations) > 0 {
		mmSetStatus.mock.t.Fatalf("Some expectations are already set for the IOrderRepo.SetStatus method")
	}

	mmSetStatus.mock.funcSetStatus = f
	return mmSetStatus.mock
}

// When sets expectation for the IOrderRepo.SetStatus which will trigger the result defined by the following
// Then helper
func (mmSetStatus *mOrderRepoMockSetStatus) When(ctx context.Context, id int64, status model.Status) *OrderRepoMockSetStatusExpectation {
	if mmSetStatus.mock.funcSetStatus != nil {
		mmSetStatus.mock.t.Fatalf("OrderRepoMock.SetStatus mock is already set by Set")
	}

	expectation := &OrderRepoMockSetStatusExpectation{
		mock:   mmSetStatus.mock,
		params: &OrderRepoMockSetStatusParams{ctx, id, status},
	}
	mmSetStatus.expectations = append(mmSetStatus.expectations, expectation)
	return expectation
}

// Then sets up IOrderRepo.SetStatus return parameters for the expectation previously defined by the When method
func (e *OrderRepoMockSetStatusExpectation) Then(err error) *OrderRepoMock {
	e.results = &OrderRepoMockSetStatusResults{err}
	return e.mock
}

// Times sets number of times IOrderRepo.SetStatus should be invoked
func (mmSetStatus *mOrderRepoMockSetStatus) Times(n uint64) *mOrderRepoMockSetStatus {
	if n == 0 {
		mmSetStatus.mock.t.Fatalf("Times of OrderRepoMock.SetStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetStatus.expectedInvocations, n)
	return mmSetStatus
}

func (mmSetStatus *mOrderRepoMockSetStatus) invocationsDone() bool {
	if len(mmSetStatus.expectations) == 0 && mmSetStatus.defaultExpectation == nil && mmSetStatus.mock.funcSetStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetStatus.mock.afterSetStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetStatus implements order.IOrderRepo
func (mmSetStatus *OrderRepoMock) SetStatus(ctx context.Context, id int64, status model.Status) (err error) {
	mm_atomic.AddUint64(&mmSetStatus.beforeSetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmSetStatus.afterSetStatusCounter, 1)

	if mmSetStatus.inspectFuncSetStatus != nil {
		mmSetStatus.inspectFuncSetStatus(ctx, id, status)
	}

	mm_params := OrderRepoMockSetStatusParams{ctx, id, status}

	// Record call args
	mmSetStatus.SetStatusMock.mutex.Lock()
	mmSetStatus.SetStatusMock.callArgs = append(mmSetStatus.SetStatusMock.callArgs, &mm_params)
	mmSetStatus.SetStatusMock.mutex.Unlock()

	for _, e := range mmSetStatus.SetStatusMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetStatus.SetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetStatus.SetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmSetStatus.SetStatusMock.defaultExpectation.params
		mm_want_ptrs := mmSetStatus.SetStatusMock.defaultExpectation.paramPtrs

		mm_got := OrderRepoMockSetStatusParams{ctx, id, status}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameter id, want: %#v, got: %#v%s\n", *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.status != nil && !minimock.Equal(*mm_want_ptrs.status, mm_got.status) {
				mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameter status, want: %#v, got: %#v%s\n", *mm_want_ptrs.status, mm_got.status, minimock.Diff(*mm_want_ptrs.status, mm_got.status))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetStatus.t.Errorf("OrderRepoMock.SetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetStatus.SetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmSetStatus.t.Fatal("No results are set for the OrderRepoMock.SetStatus")
		}
		return (*mm_results).err
	}
	if mmSetStatus.funcSetStatus != nil {
		return mmSetStatus.funcSetStatus(ctx, id, status)
	}
	mmSetStatus.t.Fatalf("Unexpected call to OrderRepoMock.SetStatus. %v %v %v", ctx, id, status)
	return
}

// SetStatusAfterCounter returns a count of finished OrderRepoMock.SetStatus invocations
func (mmSetStatus *OrderRepoMock) SetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.afterSetStatusCounter)
}

// SetStatusBeforeCounter returns a count of OrderRepoMock.SetStatus invocations
func (mmSetStatus *OrderRepoMock) SetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetStatus.beforeSetStatusCounter)
}

// Calls returns a list of arguments used in each call to OrderRepoMock.SetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetStatus *mOrderRepoMockSetStatus) Calls() []*OrderRepoMockSetStatusParams {
	mmSetStatus.mutex.RLock()

	argCopy := make([]*OrderRepoMockSetStatusParams, len(mmSetStatus.callArgs))
	copy(argCopy, mmSetStatus.callArgs)

	mmSetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockSetStatusDone returns true if the count of the SetStatus invocations corresponds
// the number of defined expectations
func (m *OrderRepoMock) MinimockSetStatusDone() bool {
	if m.SetStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetStatusMock.invocationsDone()
}

// MinimockSetStatusInspect logs each unmet expectation
func (m *OrderRepoMock) MinimockSetStatusInspect() {
	for _, e := range m.SetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderRepoMock.SetStatus with params: %#v", *e.params)
		}
	}

	afterSetStatusCounter := mm_atomic.LoadUint64(&m.afterSetStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetStatusMock.defaultExpectation != nil && afterSetStatusCounter < 1 {
		if m.SetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderRepoMock.SetStatus")
		} else {
			m.t.Errorf("Expected call to OrderRepoMock.SetStatus with params: %#v", *m.SetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetStatus != nil && afterSetStatusCounter < 1 {
		m.t.Error("Expected call to OrderRepoMock.SetStatus")
	}

	if !m.SetStatusMock.invocationsDone() && afterSetStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to OrderRepoMock.SetStatus but found %d calls",
			mm_atomic.LoadUint64(&m.SetStatusMock.expectedInvocations), afterSetStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderRepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderInspect()

			m.MinimockGetOrderByIDInspect()

			m.MinimockSetStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockGetOrderByIDDone() &&
		m.MinimockSetStatusDone()
}
