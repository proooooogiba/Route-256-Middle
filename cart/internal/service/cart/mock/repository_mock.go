// Code generated by http://github.com/gojuno/minimock (v3.3.12). DO NOT EDIT.

package mock

//go:generate minimock -i route256/cart/internal/service/cart.Repository -o repository_mock.go -n RepositoryMock -p mock

import (
	"context"
	"route256/cart/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements cart.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(ctx context.Context, userID int64, item model.Item) (err error)
	inspectFuncAddItem   func(ctx context.Context, userID int64, item model.Item)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mRepositoryMockAddItem

	funcClear          func(ctx context.Context, userID int64) (err error)
	inspectFuncClear   func(ctx context.Context, userID int64)
	afterClearCounter  uint64
	beforeClearCounter uint64
	ClearMock          mRepositoryMockClear

	funcDeleteItem          func(ctx context.Context, userID int64, sku model.SKU) (err error)
	inspectFuncDeleteItem   func(ctx context.Context, userID int64, sku model.SKU)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mRepositoryMockDeleteItem

	funcGetItemsByUserID          func(ctx context.Context, userID int64) (ia1 []model.Item, err error)
	inspectFuncGetItemsByUserID   func(ctx context.Context, userID int64)
	afterGetItemsByUserIDCounter  uint64
	beforeGetItemsByUserIDCounter uint64
	GetItemsByUserIDMock          mRepositoryMockGetItemsByUserID
}

// NewRepositoryMock returns a mock for cart.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mRepositoryMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*RepositoryMockAddItemParams{}

	m.ClearMock = mRepositoryMockClear{mock: m}
	m.ClearMock.callArgs = []*RepositoryMockClearParams{}

	m.DeleteItemMock = mRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*RepositoryMockDeleteItemParams{}

	m.GetItemsByUserIDMock = mRepositoryMockGetItemsByUserID{mock: m}
	m.GetItemsByUserIDMock.callArgs = []*RepositoryMockGetItemsByUserIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddItem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddItemExpectation
	expectations       []*RepositoryMockAddItemExpectation

	callArgs []*RepositoryMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockAddItemExpectation specifies expectation struct of the Repository.AddItem
type RepositoryMockAddItemExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockAddItemParams
	paramPtrs *RepositoryMockAddItemParamPtrs
	results   *RepositoryMockAddItemResults
	Counter   uint64
}

// RepositoryMockAddItemParams contains parameters of the Repository.AddItem
type RepositoryMockAddItemParams struct {
	ctx    context.Context
	userID int64
	item   model.Item
}

// RepositoryMockAddItemParamPtrs contains pointers to parameters of the Repository.AddItem
type RepositoryMockAddItemParamPtrs struct {
	ctx    *context.Context
	userID *int64
	item   *model.Item
}

// RepositoryMockAddItemResults contains results of the Repository.AddItem
type RepositoryMockAddItemResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mRepositoryMockAddItem) Optional() *mRepositoryMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for Repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) Expect(ctx context.Context, userID int64, item model.Item) *mRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &RepositoryMockAddItemParams{ctx, userID, item}
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.ctx = &ctx

	return mmAddItem
}

// ExpectUserIDParam2 sets up expected param userID for Repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) ExpectUserIDParam2(userID int64) *mRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.userID = &userID

	return mmAddItem
}

// ExpectItemParam3 sets up expected param item for Repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) ExpectItemParam3(item model.Item) *mRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &RepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.item = &item

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) Inspect(f func(ctx context.Context, userID int64, item model.Item)) *mRepositoryMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by Repository.AddItem
func (mmAddItem *mRepositoryMockAddItem) Return(err error) *RepositoryMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &RepositoryMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &RepositoryMockAddItemResults{err}
	return mmAddItem.mock
}

// Set uses given function f to mock the Repository.AddItem method
func (mmAddItem *mRepositoryMockAddItem) Set(f func(ctx context.Context, userID int64, item model.Item) (err error)) *RepositoryMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the Repository.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the Repository.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	return mmAddItem.mock
}

// When sets expectation for the Repository.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mRepositoryMockAddItem) When(ctx context.Context, userID int64, item model.Item) *RepositoryMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("RepositoryMock.AddItem mock is already set by Set")
	}

	expectation := &RepositoryMockAddItemExpectation{
		mock:   mmAddItem.mock,
		params: &RepositoryMockAddItemParams{ctx, userID, item},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockAddItemResults{err}
	return e.mock
}

// Times sets number of times Repository.AddItem should be invoked
func (mmAddItem *mRepositoryMockAddItem) Times(n uint64) *mRepositoryMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of RepositoryMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	return mmAddItem
}

func (mmAddItem *mRepositoryMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements cart.Repository
func (mmAddItem *RepositoryMock) AddItem(ctx context.Context, userID int64, item model.Item) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(ctx, userID, item)
	}

	mm_params := RepositoryMockAddItemParams{ctx, userID, item}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddItemParams{ctx, userID, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddItem.t.Errorf("RepositoryMock.AddItem got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddItem.t.Errorf("RepositoryMock.AddItem got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmAddItem.t.Errorf("RepositoryMock.AddItem got unexpected parameter item, want: %#v, got: %#v%s\n", *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("RepositoryMock.AddItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the RepositoryMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(ctx, userID, item)
	}
	mmAddItem.t.Fatalf("Unexpected call to RepositoryMock.AddItem. %v %v %v", ctx, userID, item)
	return
}

// AddItemAfterCounter returns a count of finished RepositoryMock.AddItem invocations
func (mmAddItem *RepositoryMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of RepositoryMock.AddItem invocations
func (mmAddItem *RepositoryMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mRepositoryMockAddItem) Calls() []*RepositoryMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*RepositoryMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddItem with params: %#v", *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.AddItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddItem with params: %#v", *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.AddItem")
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddItem but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), afterAddItemCounter)
	}
}

type mRepositoryMockClear struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockClearExpectation
	expectations       []*RepositoryMockClearExpectation

	callArgs []*RepositoryMockClearParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockClearExpectation specifies expectation struct of the Repository.DeleteItemsByUserID
type RepositoryMockClearExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockClearParams
	paramPtrs *RepositoryMockClearParamPtrs
	results   *RepositoryMockClearResults
	Counter   uint64
}

// RepositoryMockClearParams contains parameters of the Repository.DeleteItemsByUserID
type RepositoryMockClearParams struct {
	ctx    context.Context
	userID int64
}

// RepositoryMockClearParamPtrs contains pointers to parameters of the Repository.DeleteItemsByUserID
type RepositoryMockClearParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// RepositoryMockClearResults contains results of the Repository.DeleteItemsByUserID
type RepositoryMockClearResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClear *mRepositoryMockClear) Optional() *mRepositoryMockClear {
	mmClear.optional = true
	return mmClear
}

// Expect sets up expected params for Repository.DeleteItemsByUserID
func (mmClear *mRepositoryMockClear) Expect(ctx context.Context, userID int64) *mRepositoryMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &RepositoryMockClearExpectation{}
	}

	if mmClear.defaultExpectation.paramPtrs != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by ExpectParams functions")
	}

	mmClear.defaultExpectation.params = &RepositoryMockClearParams{ctx, userID}
	for _, e := range mmClear.expectations {
		if minimock.Equal(e.params, mmClear.defaultExpectation.params) {
			mmClear.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClear.defaultExpectation.params)
		}
	}

	return mmClear
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteItemsByUserID
func (mmClear *mRepositoryMockClear) ExpectCtxParam1(ctx context.Context) *mRepositoryMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &RepositoryMockClearExpectation{}
	}

	if mmClear.defaultExpectation.params != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmClear.defaultExpectation.paramPtrs == nil {
		mmClear.defaultExpectation.paramPtrs = &RepositoryMockClearParamPtrs{}
	}
	mmClear.defaultExpectation.paramPtrs.ctx = &ctx

	return mmClear
}

// ExpectUserIDParam2 sets up expected param userID for Repository.DeleteItemsByUserID
func (mmClear *mRepositoryMockClear) ExpectUserIDParam2(userID int64) *mRepositoryMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &RepositoryMockClearExpectation{}
	}

	if mmClear.defaultExpectation.params != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Expect")
	}

	if mmClear.defaultExpectation.paramPtrs == nil {
		mmClear.defaultExpectation.paramPtrs = &RepositoryMockClearParamPtrs{}
	}
	mmClear.defaultExpectation.paramPtrs.userID = &userID

	return mmClear
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteItemsByUserID
func (mmClear *mRepositoryMockClear) Inspect(f func(ctx context.Context, userID int64)) *mRepositoryMockClear {
	if mmClear.mock.inspectFuncClear != nil {
		mmClear.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteItemsByUserID")
	}

	mmClear.mock.inspectFuncClear = f

	return mmClear
}

// Return sets up results that will be returned by Repository.DeleteItemsByUserID
func (mmClear *mRepositoryMockClear) Return(err error) *RepositoryMock {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &RepositoryMockClearExpectation{mock: mmClear.mock}
	}
	mmClear.defaultExpectation.results = &RepositoryMockClearResults{err}
	return mmClear.mock
}

// Set uses given function f to mock the Repository.DeleteItemsByUserID method
func (mmClear *mRepositoryMockClear) Set(f func(ctx context.Context, userID int64) (err error)) *RepositoryMock {
	if mmClear.defaultExpectation != nil {
		mmClear.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteItemsByUserID method")
	}

	if len(mmClear.expectations) > 0 {
		mmClear.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteItemsByUserID method")
	}

	mmClear.mock.funcClear = f
	return mmClear.mock
}

// When sets expectation for the Repository.DeleteItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmClear *mRepositoryMockClear) When(ctx context.Context, userID int64) *RepositoryMockClearExpectation {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.DeleteItemsByUserID mock is already set by Set")
	}

	expectation := &RepositoryMockClearExpectation{
		mock:   mmClear.mock,
		params: &RepositoryMockClearParams{ctx, userID},
	}
	mmClear.expectations = append(mmClear.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteItemsByUserID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockClearExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockClearResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteItemsByUserID should be invoked
func (mmClear *mRepositoryMockClear) Times(n uint64) *mRepositoryMockClear {
	if n == 0 {
		mmClear.mock.t.Fatalf("Times of RepositoryMock.DeleteItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClear.expectedInvocations, n)
	return mmClear
}

func (mmClear *mRepositoryMockClear) invocationsDone() bool {
	if len(mmClear.expectations) == 0 && mmClear.defaultExpectation == nil && mmClear.mock.funcClear == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClear.mock.afterClearCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClear.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Clear implements cart.Repository
func (mmClear *RepositoryMock) DeleteItemsByUserID(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmClear.beforeClearCounter, 1)
	defer mm_atomic.AddUint64(&mmClear.afterClearCounter, 1)

	if mmClear.inspectFuncClear != nil {
		mmClear.inspectFuncClear(ctx, userID)
	}

	mm_params := RepositoryMockClearParams{ctx, userID}

	// Record call args
	mmClear.ClearMock.mutex.Lock()
	mmClear.ClearMock.callArgs = append(mmClear.ClearMock.callArgs, &mm_params)
	mmClear.ClearMock.mutex.Unlock()

	for _, e := range mmClear.ClearMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClear.ClearMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClear.ClearMock.defaultExpectation.Counter, 1)
		mm_want := mmClear.ClearMock.defaultExpectation.params
		mm_want_ptrs := mmClear.ClearMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockClearParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClear.t.Errorf("RepositoryMock.DeleteItemsByUserID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClear.t.Errorf("RepositoryMock.DeleteItemsByUserID got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClear.t.Errorf("RepositoryMock.DeleteItemsByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClear.ClearMock.defaultExpectation.results
		if mm_results == nil {
			mmClear.t.Fatal("No results are set for the RepositoryMock.DeleteItemsByUserID")
		}
		return (*mm_results).err
	}
	if mmClear.funcClear != nil {
		return mmClear.funcClear(ctx, userID)
	}
	mmClear.t.Fatalf("Unexpected call to RepositoryMock.DeleteItemsByUserID. %v %v", ctx, userID)
	return
}

// ClearAfterCounter returns a count of finished RepositoryMock.Clear invocations
func (mmClear *RepositoryMock) ClearAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.afterClearCounter)
}

// ClearBeforeCounter returns a count of RepositoryMock.Clear invocations
func (mmClear *RepositoryMock) ClearBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.beforeClearCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Clear.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClear *mRepositoryMockClear) Calls() []*RepositoryMockClearParams {
	mmClear.mutex.RLock()

	argCopy := make([]*RepositoryMockClearParams, len(mmClear.callArgs))
	copy(argCopy, mmClear.callArgs)

	mmClear.mutex.RUnlock()

	return argCopy
}

// MinimockClearDone returns true if the count of the Clear invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockClearDone() bool {
	if m.ClearMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearMock.invocationsDone()
}

// MinimockClearInspect logs each unmet expectation
func (m *RepositoryMock) MinimockClearInspect() {
	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsByUserID with params: %#v", *e.params)
		}
	}

	afterClearCounter := mm_atomic.LoadUint64(&m.afterClearCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearMock.defaultExpectation != nil && afterClearCounter < 1 {
		if m.ClearMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteItemsByUserID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItemsByUserID with params: %#v", *m.ClearMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClear != nil && afterClearCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteItemsByUserID")
	}

	if !m.ClearMock.invocationsDone() && afterClearCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteItemsByUserID but found %d calls",
			mm_atomic.LoadUint64(&m.ClearMock.expectedInvocations), afterClearCounter)
	}
}

type mRepositoryMockDeleteItem struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteItemExpectation
	expectations       []*RepositoryMockDeleteItemExpectation

	callArgs []*RepositoryMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockDeleteItemExpectation specifies expectation struct of the Repository.DeleteItem
type RepositoryMockDeleteItemExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockDeleteItemParams
	paramPtrs *RepositoryMockDeleteItemParamPtrs
	results   *RepositoryMockDeleteItemResults
	Counter   uint64
}

// RepositoryMockDeleteItemParams contains parameters of the Repository.DeleteItem
type RepositoryMockDeleteItemParams struct {
	ctx    context.Context
	userID int64
	sku    model.SKU
}

// RepositoryMockDeleteItemParamPtrs contains pointers to parameters of the Repository.DeleteItem
type RepositoryMockDeleteItemParamPtrs struct {
	ctx    *context.Context
	userID *int64
	sku    *model.SKU
}

// RepositoryMockDeleteItemResults contains results of the Repository.DeleteItem
type RepositoryMockDeleteItemResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mRepositoryMockDeleteItem) Optional() *mRepositoryMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for Repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) Expect(ctx context.Context, userID int64, sku model.SKU) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &RepositoryMockDeleteItemParams{ctx, userID, sku}
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectCtxParam1 sets up expected param ctx for Repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) ExpectCtxParam1(ctx context.Context) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteItem
}

// ExpectUserIDParam2 sets up expected param userID for Repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) ExpectUserIDParam2(userID int64) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.userID = &userID

	return mmDeleteItem
}

// ExpectSkuParam3 sets up expected param sku for Repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) ExpectSkuParam3(sku model.SKU) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &RepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.sku = &sku

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) Inspect(f func(ctx context.Context, userID int64, sku model.SKU)) *mRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by Repository.DeleteItem
func (mmDeleteItem *mRepositoryMockDeleteItem) Return(err error) *RepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &RepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &RepositoryMockDeleteItemResults{err}
	return mmDeleteItem.mock
}

// Set uses given function f to mock the Repository.DeleteItem method
func (mmDeleteItem *mRepositoryMockDeleteItem) Set(f func(ctx context.Context, userID int64, sku model.SKU) (err error)) *RepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	return mmDeleteItem.mock
}

// When sets expectation for the Repository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mRepositoryMockDeleteItem) When(ctx context.Context, userID int64, sku model.SKU) *RepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("RepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteItemExpectation{
		mock:   mmDeleteItem.mock,
		params: &RepositoryMockDeleteItemParams{ctx, userID, sku},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteItemExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times Repository.DeleteItem should be invoked
func (mmDeleteItem *mRepositoryMockDeleteItem) Times(n uint64) *mRepositoryMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of RepositoryMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	return mmDeleteItem
}

func (mmDeleteItem *mRepositoryMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements cart.Repository
func (mmDeleteItem *RepositoryMock) DeleteItem(ctx context.Context, userID int64, sku model.SKU) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(ctx, userID, sku)
	}

	mm_params := RepositoryMockDeleteItemParams{ctx, userID, sku}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteItemParams{ctx, userID, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteItem.t.Errorf("RepositoryMock.DeleteItem got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItem.t.Errorf("RepositoryMock.DeleteItem got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmDeleteItem.t.Errorf("RepositoryMock.DeleteItem got unexpected parameter sku, want: %#v, got: %#v%s\n", *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("RepositoryMock.DeleteItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the RepositoryMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(ctx, userID, sku)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to RepositoryMock.DeleteItem. %v %v %v", ctx, userID, sku)
	return
}

// DeleteItemAfterCounter returns a count of finished RepositoryMock.DeleteItem invocations
func (mmDeleteItem *RepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of RepositoryMock.DeleteItem invocations
func (mmDeleteItem *RepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mRepositoryMockDeleteItem) Calls() []*RepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItem with params: %#v", *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteItem")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteItem with params: %#v", *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteItem")
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteItem but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), afterDeleteItemCounter)
	}
}

type mRepositoryMockGetItemsByUserID struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetItemsByUserIDExpectation
	expectations       []*RepositoryMockGetItemsByUserIDExpectation

	callArgs []*RepositoryMockGetItemsByUserIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// RepositoryMockGetItemsByUserIDExpectation specifies expectation struct of the Repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDExpectation struct {
	mock      *RepositoryMock
	params    *RepositoryMockGetItemsByUserIDParams
	paramPtrs *RepositoryMockGetItemsByUserIDParamPtrs
	results   *RepositoryMockGetItemsByUserIDResults
	Counter   uint64
}

// RepositoryMockGetItemsByUserIDParams contains parameters of the Repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDParams struct {
	ctx    context.Context
	userID int64
}

// RepositoryMockGetItemsByUserIDParamPtrs contains pointers to parameters of the Repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// RepositoryMockGetItemsByUserIDResults contains results of the Repository.GetItemsByUserID
type RepositoryMockGetItemsByUserIDResults struct {
	ia1 []model.Item
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Optional() *mRepositoryMockGetItemsByUserID {
	mmGetItemsByUserID.optional = true
	return mmGetItemsByUserID
}

// Expect sets up expected params for Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Expect(ctx context.Context, userID int64) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by ExpectParams functions")
	}

	mmGetItemsByUserID.defaultExpectation.params = &RepositoryMockGetItemsByUserIDParams{ctx, userID}
	for _, e := range mmGetItemsByUserID.expectations {
		if minimock.Equal(e.params, mmGetItemsByUserID.defaultExpectation.params) {
			mmGetItemsByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByUserID.defaultExpectation.params)
		}
	}

	return mmGetItemsByUserID
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &RepositoryMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetItemsByUserID
}

// ExpectUserIDParam2 sets up expected param userID for Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) ExpectUserIDParam2(userID int64) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{}
	}

	if mmGetItemsByUserID.defaultExpectation.params != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Expect")
	}

	if mmGetItemsByUserID.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUserID.defaultExpectation.paramPtrs = &RepositoryMockGetItemsByUserIDParamPtrs{}
	}
	mmGetItemsByUserID.defaultExpectation.paramPtrs.userID = &userID

	return mmGetItemsByUserID
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Inspect(f func(ctx context.Context, userID int64)) *mRepositoryMockGetItemsByUserID {
	if mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetItemsByUserID")
	}

	mmGetItemsByUserID.mock.inspectFuncGetItemsByUserID = f

	return mmGetItemsByUserID
}

// Return sets up results that will be returned by Repository.GetItemsByUserID
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Return(ia1 []model.Item, err error) *RepositoryMock {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	if mmGetItemsByUserID.defaultExpectation == nil {
		mmGetItemsByUserID.defaultExpectation = &RepositoryMockGetItemsByUserIDExpectation{mock: mmGetItemsByUserID.mock}
	}
	mmGetItemsByUserID.defaultExpectation.results = &RepositoryMockGetItemsByUserIDResults{ia1, err}
	return mmGetItemsByUserID.mock
}

// Set uses given function f to mock the Repository.GetItemsByUserID method
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Set(f func(ctx context.Context, userID int64) (ia1 []model.Item, err error)) *RepositoryMock {
	if mmGetItemsByUserID.defaultExpectation != nil {
		mmGetItemsByUserID.mock.t.Fatalf("Default expectation is already set for the Repository.GetItemsByUserID method")
	}

	if len(mmGetItemsByUserID.expectations) > 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Some expectations are already set for the Repository.GetItemsByUserID method")
	}

	mmGetItemsByUserID.mock.funcGetItemsByUserID = f
	return mmGetItemsByUserID.mock
}

// When sets expectation for the Repository.GetItemsByUserID which will trigger the result defined by the following
// Then helper
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) When(ctx context.Context, userID int64) *RepositoryMockGetItemsByUserIDExpectation {
	if mmGetItemsByUserID.mock.funcGetItemsByUserID != nil {
		mmGetItemsByUserID.mock.t.Fatalf("RepositoryMock.GetItemsByUserID mock is already set by Set")
	}

	expectation := &RepositoryMockGetItemsByUserIDExpectation{
		mock:   mmGetItemsByUserID.mock,
		params: &RepositoryMockGetItemsByUserIDParams{ctx, userID},
	}
	mmGetItemsByUserID.expectations = append(mmGetItemsByUserID.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetItemsByUserID return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetItemsByUserIDExpectation) Then(ia1 []model.Item, err error) *RepositoryMock {
	e.results = &RepositoryMockGetItemsByUserIDResults{ia1, err}
	return e.mock
}

// Times sets number of times Repository.GetItemsByUserID should be invoked
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Times(n uint64) *mRepositoryMockGetItemsByUserID {
	if n == 0 {
		mmGetItemsByUserID.mock.t.Fatalf("Times of RepositoryMock.GetItemsByUserID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemsByUserID.expectedInvocations, n)
	return mmGetItemsByUserID
}

func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) invocationsDone() bool {
	if len(mmGetItemsByUserID.expectations) == 0 && mmGetItemsByUserID.defaultExpectation == nil && mmGetItemsByUserID.mock.funcGetItemsByUserID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.mock.afterGetItemsByUserIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemsByUserID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemsByUserID implements cart.Repository
func (mmGetItemsByUserID *RepositoryMock) GetItemsByUserID(ctx context.Context, userID int64) (ia1 []model.Item, err error) {
	mm_atomic.AddUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter, 1)

	if mmGetItemsByUserID.inspectFuncGetItemsByUserID != nil {
		mmGetItemsByUserID.inspectFuncGetItemsByUserID(ctx, userID)
	}

	mm_params := RepositoryMockGetItemsByUserIDParams{ctx, userID}

	// Record call args
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Lock()
	mmGetItemsByUserID.GetItemsByUserIDMock.callArgs = append(mmGetItemsByUserID.GetItemsByUserIDMock.callArgs, &mm_params)
	mmGetItemsByUserID.GetItemsByUserIDMock.mutex.Unlock()

	for _, e := range mmGetItemsByUserID.GetItemsByUserIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetItemsByUserIDParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItemsByUserID.t.Errorf("RepositoryMock.GetItemsByUserID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetItemsByUserID.t.Errorf("RepositoryMock.GetItemsByUserID got unexpected parameter userID, want: %#v, got: %#v%s\n", *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByUserID.t.Errorf("RepositoryMock.GetItemsByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByUserID.GetItemsByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByUserID.t.Fatal("No results are set for the RepositoryMock.GetItemsByUserID")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetItemsByUserID.funcGetItemsByUserID != nil {
		return mmGetItemsByUserID.funcGetItemsByUserID(ctx, userID)
	}
	mmGetItemsByUserID.t.Fatalf("Unexpected call to RepositoryMock.GetItemsByUserID. %v %v", ctx, userID)
	return
}

// GetItemsByUserIDAfterCounter returns a count of finished RepositoryMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *RepositoryMock) GetItemsByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.afterGetItemsByUserIDCounter)
}

// GetItemsByUserIDBeforeCounter returns a count of RepositoryMock.GetItemsByUserID invocations
func (mmGetItemsByUserID *RepositoryMock) GetItemsByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUserID.beforeGetItemsByUserIDCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetItemsByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByUserID *mRepositoryMockGetItemsByUserID) Calls() []*RepositoryMockGetItemsByUserIDParams {
	mmGetItemsByUserID.mutex.RLock()

	argCopy := make([]*RepositoryMockGetItemsByUserIDParams, len(mmGetItemsByUserID.callArgs))
	copy(argCopy, mmGetItemsByUserID.callArgs)

	mmGetItemsByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByUserIDDone returns true if the count of the GetItemsByUserID invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetItemsByUserIDDone() bool {
	if m.GetItemsByUserIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsByUserIDMock.invocationsDone()
}

// MinimockGetItemsByUserIDInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetItemsByUserIDInspect() {
	for _, e := range m.GetItemsByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID with params: %#v", *e.params)
		}
	}

	afterGetItemsByUserIDCounter := mm_atomic.LoadUint64(&m.afterGetItemsByUserIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserIDMock.defaultExpectation != nil && afterGetItemsByUserIDCounter < 1 {
		if m.GetItemsByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetItemsByUserID")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetItemsByUserID with params: %#v", *m.GetItemsByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUserID != nil && afterGetItemsByUserIDCounter < 1 {
		m.t.Error("Expected call to RepositoryMock.GetItemsByUserID")
	}

	if !m.GetItemsByUserIDMock.invocationsDone() && afterGetItemsByUserIDCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetItemsByUserID but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsByUserIDMock.expectedInvocations), afterGetItemsByUserIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockClearInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockGetItemsByUserIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockClearDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockGetItemsByUserIDDone()
}
